## Turing Competition - 700

### Level 1

0000....1111....

- empty string을 accept한다
- 0에서 시작하여 오른쪽으로 이동한다
- 1로 바뀌거나, BLANK에 도달한다
- 1로 바뀐 경우, 다시 오른쪽으로 이동한다
- 다시 0으로 바뀐 경우 not accept
- BLACK에 도달한 경우 accept

### Level 2

1이 13n+2개 (n>=0)

- state를 0, 1, ... 12 까지로 나눈다.
- state 0에서 시작하여 1이 등장할 때마다 오른쪽으로 이동하면서 state를 증가시킨다. (단, state 12 -> state 0)
- state 2에서 BLACK에 도달했을 경우 accept

### Level 3

000...111... ( 각 n개)

- 0 하나를 읽으면 이를 마킹(x)하고, 오른쪽으로 1이 있는 곳까지 이동하여 1을 찾고 마킹(y)한다.
- 다시 돌아와서 0을 찾고 위의 과정을 반복한다.
- 0을 마킹하고 난 뒤, 오른쪽으로 가서 1을 찾지 못하고 BLANK에 도달했다면 not accept
- 1을 마킹하고 난 뒤, 왼쪽으로 가서 0을 찾지 못하고 BLACK에 도달했다면, 다시 오른쪽으로 가서 1이 안 남아있는 지 확인하고, 1이 남아있다면 not accept, BLANK에 도달한다면 accept

### Level 4

0...(n = prime)

- 1이 포함되어 있는 지 확인한다
- n=1, n=2를 확인한다 (특수 케이스)
- 오른쪽에 n-1개의 1(y)를 추가한다. 이는 약수로 사용한다.

- 약수는 순서대로 2,3,4,...,n-1개를 마킹(d)하여 현재 해당하는 숫자를 나누려고 한다는 것을 의미한다.

- n을 d로 나누려고 하는 상황을 가정하자 초기 상태는 아래와 같다

  - xxx...xxxddd...dddyyy...yyy
  - x = n개, d = d개, y=n-1-d개


- 가장 오른쪽의 d를 dMark로 바꾼다. 왼쪽으로 가서 가장 오른쪽의 x를 xMark로 바꾼다
- 이를 모든 d가 dMark가 될 때까지 반복한다.
- 모든 d가 dMark가 되었을 때
  - 모든 x가 xMark가 되었으면, 나누어지는 것이므로 not accept
  - 아직 남은 x가 있으면, dMark를 모두 d로 바꾸고 반복
- 모든 x가 xMark가 되었을 때
  - 모든 d가 dMark가 되었으면, 나누어지는 것이므로 not accept
  - d가 남아있으면 나누어떨어지지 않는 것이므로 d를 1 증가시키고 반복
    - 이때 만약 d가 n-1이면 accept
